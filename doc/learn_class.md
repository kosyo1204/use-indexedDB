クラスを使えるようになるのはクラス宣言よりも後。
クラスのプロパティで初期値を設定できる。
初期値は設定するか、コンストラクタで設定するかが必要。
もしくはオプショナルなプロパティとするか。

# コンストラクタ
主な使い道は初期値の設定。
コンストラクタが引数を受け取るには、newするときに与える必要がある。
外から与えられた入力に応じてプロパティの初期値を決めたいときに利用可能。
コンストラクタはもう一つ独自の特徴がある。自身の読み取り専用プロパティにも代入できる。

# 静的プロパティ・静的メソッド
クラス宣言には静的プロパティ・静的メソッドの宣言を含めることができる。
プロパティ・メソッドの宣言の前にstaticと付ければよい。
インスタンスではなく、クラスそのものに属するプロパティ・メソッド。

# 3つのアクセシビリティ修飾子
private修飾子がついたプロパティはクラスの内部からしかアクセスできない。＝クラスの外からアクセスしようとしてもエラーとなる。
メソッドを通じて間接的に取得する、といったことしかできなくすることができる。
外からプロパティを隠すことができる。インスタンスを使う側からは無関係の存在を作ることができる。

# コンストラクタ引数でのプロパティ宣言
アクセシビリティ修飾子をつければ、プロパティの初期化をより簡単にできる。

# クラス式でクラスを作成する
関数式のようにクラスを作ることができる。
ただし、アクセシビリティ修飾子を使えない、という制限がある。
そのため、基本的にはクラス式は使わない。

# もう一つのプライベートプロパティ
privateではなく、#で宣言することもできる。
JS由来のもの。コンパイル時だけでなく、JSで実行するときにもチェックされる。
どちらを使っても良いが、より厳格にチェックしたい場合は#で宣言する。

# 型引数を持つクラス
クラス宣言でクラス名＜型引数リスト＞
これにより、クラス名＜string＞のようなインスタンスを作ることができる。


# 5.2 クラスの型
## クラス宣言はインスタンスの型を作る
クラスオブジェクトという値を作るものであると同時に、インスタンスの型を宣言するもの。
class Userを宣言すれば、User型を作る。

# 5.3 クラスの継承
## 子は親の機能を受けつぐ
extendsを使うことでクラス宣言・クラス式において継承を行う。
class クラス名 extends 親クラス {...}
親クラスの機能に加えて、子クラスで定義した機能を持つ。

## 親の機能を上書きする
再宣言するには条件があり、子クラスのインスタンスは親クラスのインスタンスの部分型であるという原則を持つ。
親クラスを拡張したものなので、親クラスとして使える必要がある。メソッドの返り血の型を合わせる、など。
コンストラクタをオーバーライドすることもできる。コンストラクタの中にsuperを含める必要がある。
superとは、親クラスのコンストラクタを呼び出すための構文。
thisよりも先にsuperする必要がある。

## override修飾子とその威力
override修飾子は必須ではないが、明示できる。
noImplicitOverrideコンパイラオプションとお併用することで、威力がます。

## privateとprotectedの動作と使い所
protectedは外部からはアクセスできないが、子クラスからはアクセスできるプロパティ・メソッドを表すもの。
privateは子クラスからもアクセスできない。
子クラスで書き換えられては困るようなプロパティは、protectedを使わない。

## implementsキーワードによるクラスの型チェック
クラスのインスタンスは与えられた型の部分型であるという宣言。

# 5.4 this
関数の中のthisは、関数の呼び出し方によって決まる。
アロー関数におけるthisはthisを外側の関数から受け継ぐ。
つまり、自身のthisを持たない。　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　
