# 目的
- IndexedDBは非同期処理でDBに保存するため、Promiseに対する理解が必要と考える。
- また、DBへの保存以外でも非同期処理を行う可能性はあると思われる。

# 非同期処理とは
裏で行われる処理。
APIはブロッキング、ノンブロッキングに2分される。
TypeScriptの非同期処理はノンブロッキンングなものとなる
ブロッキングな処理とは、処理が完了するまでプログラムが停止するもの。
JS,TypeScriptは、シングルスレッドであるため、ブロッキングな処理は好まれない。

# コールバック
最も原始的な手法が、コールバック関数。
コールバック関数とは、非同期処理が終わったら呼び出される関数。
コールバック関数を使う場合、実行を開始するときに終了時に呼び出される関数を登録しておく。非同期処理が完了したら呼び出される。

TypeScriptにおいて、動機的に実行しているプログラムに非同期処理が割り込むことはない。

# Promise
ES2015で追加された非同期処理のための機能。
非同期処理においては、「終わった後に何をするか」を表す関数が不可欠。
コールバック関数ベースの非同期処理の場合
  非同期処理を開始する関数に直接コールバック関数として渡していた。
Promiseベースの場合
  非同期処理を行う関数は関数を受け取らない。Promiseオブジェクトを返す。
  Promiseオブジェクトに対し、終わった後に行う処理を表す関数を登録する。
Promiseオブジェクトはthenメソッドを持つ。thenメソッドは引数としてコールバック関数を受け取る。
コールバック関数ベースの非同期処理との違い
  コールバック関数ベース: 非同期処理を行う関数にコールバック関数を直接渡す
  Promiseベース      : 非同期処理を行う関数はPromiseオブジェクトを返す、返されたPromiseオブジェクトにthenでコールバック関数を渡す

## 使い方
thenにコールバック関数を登録する
Promiseオブジェクトには、成功と失敗がある。
失敗時のコールバック関数は、catchメソッドに渡す。
thenには、成功時の関数と失敗時の関数を同時に登録する機能もある。

finallyというメソッドも持つ。成功しても失敗しても呼び出される関数を登録できる。
Promiseチェーンに組み込むと意味がわかってくる。

Promiseオブジェクトを自分で作ることもできる。
  

## 静的メソッド
静的メソッドとは、Promiseクラスに対して直接プロパティアクセスすることで使えるメソッド。クラスそのものに属するメソッド。
簡単なメソッドは、Promise.resolve、Promise.reject
Promise.resolveは成功を、Promise.rejectは失敗のオブジェクトを作る。

残りのPromiseオブジェクトは、複数のPromiseオブジェクトを組み合わせて新しいPromiseオブジェクトを作るためのメソッド。
Promise.all
  複数のPromiseを合成するメソッド。
  Promiseオブジェクトの配列を引数として受け取り、全てが成功したら成功となるPromiseオブジェクトを作って返す。
  例えば、３つのファイルを読み込み処理を行い、すべての処理が終わったら次へ進むなど。
  const p = Promise.all([p1, p2, p3])
  p.then((result) => {
    // 結果はresultに配列で。
    result[0], result[1], result[2]
  })
  １つでも失敗すると最初に失敗したPromiseオブジェクトのエラーを返す。
Promise.race
  Promise.allと同じようにPromiseの配列を受け取る。
  最も早く成功または失敗したものの結果を、全体の結果とする。

Promise.allSettled

Promise.any
  いずれかが成功すると、全体の結果も成功となる。
  Promise.raceはどんな結果でも最速で用いるが、Promise.anyは最も早く成功した結果を使う。

Promiseチェーン
  then, catch, finallyといったPromiseのメソッドは、新しいPromiseオブジェクトを返す
  成功、失敗した時の挙動をもつとともに、新しいオブジェクトを作ることを覚えておく。
  catchはPromiseの失敗を成功に変換することもできる。

  非同期処理の連鎖
    Promiseチェーンを用いることでPromiseの結果を変換できることを学んだ。
    さらなる真価は、非同期処理を連鎖させることで発揮される。
    Promiseはネストされない。Promiseの結果を次のPromiseに渡すイメージ。
    つまり、直列的に実行される。

  エラーの扱い
    成功を失敗に変換することもできる。
    失敗の可能性があるときは、必ずcatchすること。

# async/await
  Promiseをベースとする。
  async関数の返り値は必ずPromiseとなる。
  async関数の中でreturn文が実行されるとreturnで返した値がPromiseの結果となる。
  async関数で発生した例外は、async関数が返すPromiseに伝わる。

  await式はasync関数の中で使える構文。与えられたPromiseの結果が出るまで待つもの。
  awaitに与えるのは、Promiseオブジェクト。

  Promiseの結果は本来、thenメソッドで得るものだが、
  async関数の中でawait式を使うことでPromiseの結果を得ることができる。
  awaitがPromiseを待つという働きを持ち、thenの代わりとなっているため。

  ある非同期処理が終わってから次の非同期処理をする、というプログラムを
  まるで同期プログラムのように、上から下に書くことができる。

  awaitとエラー処理
    await pのようにPromiseno結果を待っていて、pが失敗した場合、
    await式で例外が発生したことになる
    awaitを使うことでPromiseのエラー処理をcatchではなくtry-catchでかける。





